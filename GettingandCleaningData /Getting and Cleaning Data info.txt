Getting and Cleaning Data
 
Lesson 1:
   
| Use select(cran, size:ip_id) to select all columns
| from size through ip_id. Store the result in cran2.

> cran2 <- select(cran, size:ip_id)

| Your dedication is inspiring!

  |===============================================================                     |  75%

| Now, to order the ROWS of cran2 so that ip_id is in
| ascending order (from small to large), type
| arrange(cran2, ip_id). You may want to make your
| console wide enough so that you can see ip_id, which
| is the last column.

> arrange(cran2, ip_id)
Source: local data frame [225,468 x 8]

     size r_version r_arch         r_os     package
1   80589     3.1.0 x86_64      mingw32   htmltools
2  180562     3.0.2 x86_64      mingw32        yaml
3  190120     3.1.0   i386      mingw32       babel
4  321767     3.1.0 x86_64      mingw32     tseries
5   52281     3.0.3 x86_64 darwin10.8.0    quadprog
6  876702     3.1.0 x86_64    linux-gnu         zoo
7  321764     3.0.2 x86_64    linux-gnu     tseries
8  876702     3.1.0 x86_64    linux-gnu         zoo
9  321768     3.1.0 x86_64      mingw32     tseries
10 784093     3.1.0 x86_64    linux-gnu strucchange
..    ...       ...    ...          ...         ...
Variables not shown: version (chr), country (chr),
  ip_id (int)

| All that hard work is paying off!

  |================================================================                    |  76%

| To do the same, but in descending order, change the
| second argument to desc(ip_id), where desc() stands
| for 'descending'. Go ahead.

> arrange(cran2, desc(ip_id))
Source: local data frame [225,468 x 8]

      size r_version r_arch         r_os      package
1     5933        NA     NA           NA          CPE
2   569241     3.1.0 x86_64      mingw32 multcompView
3   228444     3.1.0 x86_64      mingw32        tourr
4   308962     3.1.0 x86_64 darwin13.1.0          ctv
5   950964     3.0.3   i386      mingw32        knitr
6    80185     3.0.3   i386      mingw32    htmltools
7  1431750     3.0.3   i386      mingw32        shiny
8  2189695     3.1.0 x86_64      mingw32       RMySQL
9  4818024     3.1.0   i386      mingw32       igraph
10  197495     3.1.0 x86_64      mingw32         coda
..     ...       ...    ...          ...          ...
Variables not shown: version (chr), country (chr),
  ip_id (int)

| All that practice is paying off!

  |=================================================================                   |  78%

| We can also arrange the data according to the values
| of multiple variables. For example, arrange(cran2,
| package, ip_id) will first arrange by package names
| (ascending alphabetically), then by ip_id. This
| means that if there are multiple rows with the same
| value for package, they will be sorted by ip_id
| (ascending numerically). Try arrange(cran2, package,
| ip_id) now.

> arrange(cran2, package, ip_id)
Source: local data frame [225,468 x 8]

    size r_version r_arch         r_os package version
1  71677     3.0.3 x86_64 darwin10.8.0      A3   0.9.2
2  71672     3.1.0 x86_64    linux-gnu      A3   0.9.2
3  71677     3.1.0 x86_64      mingw32      A3   0.9.2
4  70438     3.0.1 x86_64 darwin10.8.0      A3   0.9.2
5  71677        NA     NA           NA      A3   0.9.2
6  71892     3.0.2 x86_64    linux-gnu      A3   0.9.2
7  71677     3.1.0 x86_64    linux-gnu      A3   0.9.2
8  71672     3.1.0 x86_64      mingw32      A3   0.9.2
9  71677     3.0.3 x86_64      mingw32      A3   0.9.2
10 71672     3.1.0 x86_64      mingw32      A3   0.9.2
..   ...       ...    ...          ...     ...     ...
Variables not shown: country (chr), ip_id (int)

| Excellent job!

  |===================================================================                 |  80%

| Arrange cran2 by the following three variables, in
| this order: country (ascending), r_version
| (descending), and ip_id (ascending).

> arrange(cran2, country, desc(r_version), ip_id)
Source: local data frame [225,468 x 8]

      size r_version r_arch      r_os       package
1  1556858     3.1.1   i386   mingw32 RcppArmadillo
2  1823512     3.1.0 x86_64 linux-gnu          mgcv
3    15732     3.1.0   i686 linux-gnu          grnn
4  3014840     3.1.0 x86_64   mingw32          Rcpp
5   660087     3.1.0   i386   mingw32           xts
6   522261     3.1.0   i386   mingw32           FNN
7   522263     3.1.0   i386   mingw32           FNN
8  1676627     3.1.0 x86_64 linux-gnu         rgeos
9  2118530     3.1.0 x86_64 linux-gnu     spacetime
10 2217180     3.1.0 x86_64   mingw32         gstat
..     ...       ...    ...       ...           ...
Variables not shown: version (chr), country (chr),
  ip_id (int)

| You are really on a roll!

  |====================================================================                |  81%

| To illustrate the next major function in dplyr,
| let's take another subset of our original data. Use
| select() to grab 3 columns -- ip_id, package, and
| size (in that order) -- and store the result in a
| new variable called cran3.

> cran2 <- select(cran, ip_id, package, size)

| Almost! Try again. Or, type info() for more options.

| cran3 <- select(cran, ip_id, package, size) will
| store just these three columns in a new variable
| called cran3.

> cran3 <- select(cran, ip_id, package, size)

| Keep up the great work!

  |======================================================================              |  83%

| Take a look at cran3 now.

> cran3
Source: local data frame [225,468 x 3]

   ip_id      package    size
1      1    htmltools   80589
2      2      tseries  321767
3      3        party  748063
4      3        Hmisc  606104
5      4       digest   79825
6      3 randomForest   77681
7      3         plyr  393754
8      5      whisker   28216
9      6         Rcpp    5928
10     7     hflights 2206029
..   ...          ...     ...

| You are quite good my friend!

  |=======================================================================             |  85%

| It's common to create a new variable based on the
| value of one or more variables already in a dataset.
| The mutate() function does exactly this.

...

  |=========================================================================           |  86%

| The size variable represents the download size in
| bytes, which are units of computer memory. These
| days, megabytes (MB) are a more common unit of
| measurement. One megabyte is equal to 2^20 bytes.
| That's 2 to the power of 20, which is approximately
| one million bytes!

...

  |==========================================================================          |  88%

| We want to add a column called size_mb that contains
| the download size in megabytes. Here's the code to
| do it:
| 
| mutate(cran3, size_mb = size / 2^20)

> mutate(cran3, size_mb = size / 2^20)
Source: local data frame [225,468 x 4]

   ip_id      package    size     size_mb
1      1    htmltools   80589 0.076855659
2      2      tseries  321767 0.306860924
3      3        party  748063 0.713408470
4      3        Hmisc  606104 0.578025818
5      4       digest   79825 0.076127052
6      3 randomForest   77681 0.074082375
7      3         plyr  393754 0.375513077
8      5      whisker   28216 0.026908875
9      6         Rcpp    5928 0.005653381
10     7     hflights 2206029 2.103833199
..   ...          ...     ...         ...

| Keep working like that and you'll get there!

  |===========================================================================         |  90%

| An even larger unit of memory is a gigabyte (GB),
| which equals 2^10 megabytes. We might as well add
| another column for download size in gigabytes!

...

  |=============================================================================       |  92%

| One very nice feature of mutate() is that you can
| use the value computed for your second column
| (size_mb) to create a third column, all in the same
| line of code. To see this in action, repeat the
| exact same command as above, except add a third
| argument creating a column that is named size_gb and
| equal to size_mb / 2^10.

> mutate(cran3, size_gb = size_mb / 2^10)
Error in mutate_impl(.data, dots) : object 'size_mb' not found
> mutate(cran3, size_mb = size / 2^20, size_gb = size_mb / 2^10)
Source: local data frame [225,468 x 5]

   ip_id      package    size     size_mb      size_gb
1      1    htmltools   80589 0.076855659 7.505435e-05
2      2      tseries  321767 0.306860924 2.996689e-04
3      3        party  748063 0.713408470 6.966880e-04
4      3        Hmisc  606104 0.578025818 5.644783e-04
5      4       digest   79825 0.076127052 7.434282e-05
6      3 randomForest   77681 0.074082375 7.234607e-05
7      3         plyr  393754 0.375513077 3.667120e-04
8      5      whisker   28216 0.026908875 2.627820e-05
9      6         Rcpp    5928 0.005653381 5.520880e-06
10     7     hflights 2206029 2.103833199 2.054525e-03
..   ...          ...     ...         ...          ...

| Keep up the great work!

  |==============================================================================      |  93%

| Let's try one more for practice. Pretend we
| discovered a glitch in the system that provided the
| original values for the size variable. All of the
| values in cran3 are 1000 bytes less than they should
| be. Using cran3, create just one new column called
| correct_size that contains the correct size.

> ls()
 [1] "cran"     "cran2"    "cran3"    "my_div"  
 [5] "my_sqrt"  "old.dir"  "path2csv" "x"       
 [9] "y"        "z"       

| That's not the answer I was looking for, but try
| again. Or, type info() for more options.

| mutate(cran3, correct_size = size + 1000) will
| create one new column that is equal to the original
| sizes plus 1000.

> mutate(cran3, correct_size = size + 1000)
Source: local data frame [225,468 x 4]

   ip_id      package    size correct_size
1      1    htmltools   80589        81589
2      2      tseries  321767       322767
3      3        party  748063       749063
4      3        Hmisc  606104       607104
5      4       digest   79825        80825
6      3 randomForest   77681        78681
7      3         plyr  393754       394754
8      5      whisker   28216        29216
9      6         Rcpp    5928         6928
10     7     hflights 2206029      2207029
..   ...          ...     ...          ...

| That's the answer I was looking for.

  |================================================================================    |  95%

| The last of the five core dplyr verbs, summarize(),
| collapses the dataset to a single row. Let's say
| we're interested in knowing the average download
| size. summarize(cran, avg_bytes = mean(size)) will
| yield the mean value of the size variable. Here
| we've chosen to label the result 'avg_bytes', but we
| could have named it anything. Give it a try.

> summarize(cran, avg_bytes = mean(size))
Source: local data frame [1 x 1]

  avg_bytes
1  844086.5

| That's a job well done!

  |=================================================================================   |  97%

| That's not particularly interesting. summarize() is
| most useful when working with data that has been
| grouped by the values of a particular variable.

...

  |=================================================================================== |  98%

| We'll look at grouped data in the next lesson, but
| the idea is that summarize() can give you the
| requested value FOR EACH group in your dataset.

...

  |====================================================================================| 100%

| In this lesson, you learned how to manipulate data
| using dplyr's five main functions. In the next
| lesson, we'll look at how to take advantage of some
| other useful features of dplyr to make your life as
| a data analyst much easier.

...

| Are you currently enrolled in the Coursera course
| associated with this lesson?

1: Yes
2: No

Selection: 1

| Would you like me to notify Coursera that you've
| completed this lesson? If so, I'll need to get some
| more info from you.

1: Yes
2: No
3: Maybe later

Selection: 1

| The first item I need is your Course ID. For
| example, if the homepage for your Coursera course
| was 'https://class.coursera.org/rprog-001', then
| your course ID would be 'rprog-001' (without the
| quotes).

Course ID: SRT411
Submission login (email): tmalladin@myseneca.ca
Submission password: tcphsTMA$1

| Is the following information correct?

Course ID: SRT411
Submission login (email): tmalladin@myseneca.ca
Submission password: tcphsTMA$1

1: Yes, go ahead!
2: No, I need to change something.

Selection: 1

| I'll try to tell Coursera you've completed this
| lesson now.

| I'm sorry, something went wrong with establishing
| connection.

| Would you like to retry automatic submission or just
| submit manually?

1: Retry automatic submission
2: Submit manually

Selection: 2

| To notify Coursera that you have completed this
| lesson, please upload
| ‘SRT411_Manipulating_Data_with_dplyr.txt’ to
| Coursera manually. You may do so by visiting the
| Programming Assignments page on your course website
| and selecting the Submit button next to the
| appropriate swirl lesson. I've placed the file in
| the following directory:

/home/tim

...

Lesson 2

R version 3.1.3 (2015-03-09) -- "Smooth Sidewalk"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Workspace loaded from ~/.RData]

> library("swirl")

| Hi! I see that you have some variables saved in your
| workspace. To keep things running smoothly, I recommend you
| clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace.
| Then, type rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> swirl()

| Welcome to swirl!

| Please sign in. If you've been here before, use the same name
| as you did then. If you are new, call yourself something
| unique.

What shall I call you? Tim

| Please choose a course, or type 0 to exit swirl.

1: Getting and Cleaning Data
2: R Programming
3: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

1: Manipulating Data with dplyr
2: Grouping and Chaining with dplyr
3: Tidying Data with tidyr
4: Dates and Times with lubridate

Selection: 2

| Attemping to load lesson dependencies...

| Package ‘dplyr’ loaded correctly!

  |                                                      |   0%

| In the last lesson, you learned about the five main data
| manipulation 'verbs' in dplyr: select(), filter(), arrange(),
| mutate(), and summarize(). The last of these, summarize(), is
| most powerful when applied to grouped data.

...

  |=                                                     |   2%

| The main idea behind grouping data is that you want to break
| up your dataset into groups of rows based on the values of
| one or more variables. The group_by() function is reponsible
| for doing this.

...

  |==                                                    |   4%

| We'll continue where we left off with RStudio's CRAN download
| log from July 8, 2014, which contains information on roughly
| 225,000 R package downloads (http://cran-logs.rstudio.com/).

...

  |===                                                   |   6%

| As with the last lesson, the dplyr package was automatically installed (if necessary) and
| loaded at the beginning of this lesson. Normally, this is something you would have to do on
| your own. Just to build the habit, type library(dplyr) now to load the package again.

> library(dplyr)

| You're the best!

  |====                                                  |   8%

| I've made the dataset available to you in a data frame called mydf. Put it in a 'data frame
| tbl' using the tbl_df() function and store the result in a variable called cran. If you're
| not sure what I'm talking about, you should start with the previous lesson. Otherwise,
| practice makes perfect!

> tbl_df(mydf)
Source: local data frame [225,468 x 11]

    X       date     time    size r_version r_arch      r_os      package version country
1   1 2014-07-08 00:54:41   80589     3.1.0 x86_64   mingw32    htmltools   0.2.4      US
2   2 2014-07-08 00:59:53  321767     3.1.0 x86_64   mingw32      tseries 0.10-32      US
3   3 2014-07-08 00:47:13  748063     3.1.0 x86_64 linux-gnu        party  1.0-15      US
4   4 2014-07-08 00:48:05  606104     3.1.0 x86_64 linux-gnu        Hmisc  3.14-4      US
5   5 2014-07-08 00:46:50   79825     3.0.2 x86_64 linux-gnu       digest   0.6.4      CA
6   6 2014-07-08 00:48:04   77681     3.1.0 x86_64 linux-gnu randomForest   4.6-7      US
7   7 2014-07-08 00:48:35  393754     3.1.0 x86_64 linux-gnu         plyr   1.8.1      US
8   8 2014-07-08 00:47:30   28216     3.0.2 x86_64 linux-gnu      whisker   0.3-2      US
9   9 2014-07-08 00:54:58    5928        NA     NA        NA         Rcpp  0.10.4      CN
10 10 2014-07-08 00:15:35 2206029     3.0.2 x86_64 linux-gnu     hflights     0.1      US
.. ..        ...      ...     ...       ...    ...       ...          ...     ...     ...
Variables not shown: ip_id (int)

| Not quite! Try again. Or, type info() for more options.

| Type cran <- tbl_df(mydf) to store the data in a new tbl_df called cran.

> cran <- tbl_df(mydf)

| Nice work!

  |=====                                                 |  10%

| To avoid confusion and keep things running smoothly, let's remove the original dataframe
| from your workspace with rm("mydf").

> rm("mydf")

| You got it right!

  |======                                                |  12%

| Print cran to the console.

> cran
Source: local data frame [225,468 x 11]

    X       date     time    size r_version r_arch      r_os      package version country
1   1 2014-07-08 00:54:41   80589     3.1.0 x86_64   mingw32    htmltools   0.2.4      US
2   2 2014-07-08 00:59:53  321767     3.1.0 x86_64   mingw32      tseries 0.10-32      US
3   3 2014-07-08 00:47:13  748063     3.1.0 x86_64 linux-gnu        party  1.0-15      US
4   4 2014-07-08 00:48:05  606104     3.1.0 x86_64 linux-gnu        Hmisc  3.14-4      US
5   5 2014-07-08 00:46:50   79825     3.0.2 x86_64 linux-gnu       digest   0.6.4      CA
6   6 2014-07-08 00:48:04   77681     3.1.0 x86_64 linux-gnu randomForest   4.6-7      US
7   7 2014-07-08 00:48:35  393754     3.1.0 x86_64 linux-gnu         plyr   1.8.1      US
8   8 2014-07-08 00:47:30   28216     3.0.2 x86_64 linux-gnu      whisker   0.3-2      US
9   9 2014-07-08 00:54:58    5928        NA     NA        NA         Rcpp  0.10.4      CN
10 10 2014-07-08 00:15:35 2206029     3.0.2 x86_64 linux-gnu     hflights     0.1      US
.. ..        ...      ...     ...       ...    ...       ...          ...     ...     ...
Variables not shown: ip_id (int)

| Excellent work!

  |========                                              |  14%

| Our first goal is to group the data by package name. Bring up the help file for group_by().

> ?group_by()

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more
| options.

| Use ?group_by to bring up the documentation.

> ?group_by()

| Give it another try. Or, type info() for more options.

| Use ?group_by to bring up the documentation.

> ?group_by

| You got it!

  |=========                                             |  16%

| Group cran by the package variable and store the result in a new variable called
| by_package.

> by_package <- group_by(cran)

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Store the result of group_by(cran, package) in a new variable called by_package.

> by_package <- group_by(cran, package)

| You are really on a roll!

  |==========                                            |  18%

| Let's take a look at by_package. Print it to the console.

> 
> by_package
Source: local data frame [225,468 x 11]
Groups: package

    X       date     time    size r_version r_arch      r_os      package version country
1   1 2014-07-08 00:54:41   80589     3.1.0 x86_64   mingw32    htmltools   0.2.4      US
2   2 2014-07-08 00:59:53  321767     3.1.0 x86_64   mingw32      tseries 0.10-32      US
3   3 2014-07-08 00:47:13  748063     3.1.0 x86_64 linux-gnu        party  1.0-15      US
4   4 2014-07-08 00:48:05  606104     3.1.0 x86_64 linux-gnu        Hmisc  3.14-4      US
5   5 2014-07-08 00:46:50   79825     3.0.2 x86_64 linux-gnu       digest   0.6.4      CA
6   6 2014-07-08 00:48:04   77681     3.1.0 x86_64 linux-gnu randomForest   4.6-7      US
7   7 2014-07-08 00:48:35  393754     3.1.0 x86_64 linux-gnu         plyr   1.8.1      US
8   8 2014-07-08 00:47:30   28216     3.0.2 x86_64 linux-gnu      whisker   0.3-2      US
9   9 2014-07-08 00:54:58    5928        NA     NA        NA         Rcpp  0.10.4      CN
10 10 2014-07-08 00:15:35 2206029     3.0.2 x86_64 linux-gnu     hflights     0.1      US
.. ..        ...      ...     ...       ...    ...       ...          ...     ...     ...
Variables not shown: ip_id (int)

| That's the answer I was looking for.

  |===========                                           |  20%

| At the top of the output above, you'll see 'Groups: package', which tells us that this tbl
| has been grouped by the package variable. Everything else looks the same, but now any
| operation we apply to the grouped data will take place on a per package basis.

...

  |============                                          |  22%

| Recall that when we applied mean(size) to the original tbl_df via summarize(), it returned
| a single number -- the mean of all values in the size column. We may care about what that
| number is, but wouldn't it be so much more interesting to look at the mean download size
| for each unique package?

...

  |=============                                         |  24%

| That's exactly what you'll get if you use summarize() to apply mean(size) to the grouped
| data in by_package. Give it a shot.

> summarize(by_package)
Source: local data frame [6,023 x 1]

       package
1           A3
2  ABCExtremes
3     ABCoptim
4        ABCp2
5       ACCLMA
6          ACD
7         ACNE
8        ACTCD
9    ADGofTest
10        ADM3
..         ...

| Not quite right, but keep trying. Or, type info() for more options.

| Call summarize() with two arguments: by_package and mean(size).

> summarize(by_package, mean(size))
Source: local data frame [6,023 x 2]

       package mean(size)
1           A3   62194.96
2  ABCExtremes   22904.33
3     ABCoptim   17807.25
4        ABCp2   30473.33
5       ACCLMA   33375.53
6          ACD   99055.29
7         ACNE   96099.75
8        ACTCD  134746.27
9    ADGofTest   12262.91
10        ADM3 1077203.47
..         ...        ...

| You are doing so well!

  |==============                                        |  26%

| Instead of returning a single value, summarize() now returns the mean size for EACH package
| in our dataset.

...

  |===============                                       |  28%

| Let's take it a step further. I just opened an R script for you that contains a partially
| constructed call to summarize(). Follow the instructions in the script comments.
| 
| When you are ready to move on, save the script and type submit(), or type reset() to reset
| the script to its original state.

> submit()

| Sourcing your script...

Error in summarise_impl(.data, dots) : 
  attempt to use zero-length variable name

| Not quite, but you're learning! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Error in summarise_impl(.data, dots) : 
  attempt to use zero-length variable name

| You almost had it, but not quite. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> #
> pack_sum <- summarize(by_package,
+                       count = n(),
+                       unique = n_distinct(ip_id),
+                       countries = n_distinct(country),
+                       avg_bytes = mean(size) )
> pack_sum <- summarize(by_package,
+                       count = n(),
+                       unique = n_distinct(ip_id),
+                       countries = n_distinct(country),
+                       avg_bytes = mean(size))
> submit()

| Sourcing your script...


| You are really on a roll!

  |================                                      |  30%

| Print the resulting tbl, pack_sum, to the console to examine its contents.

> pack_sum
Source: local data frame [6,023 x 5]

       package count unique countries  avg_bytes
1           A3    25     24        10   62194.96
2  ABCExtremes    18     17         9   22904.33
3     ABCoptim    16     15         9   17807.25
4        ABCp2    18     17        10   30473.33
5       ACCLMA    15     14         9   33375.53
6          ACD    17     16        10   99055.29
7         ACNE    16     15        10   96099.75
8        ACTCD    15     14         9  134746.27
9    ADGofTest    47     44        20   12262.91
10        ADM3    17     16        10 1077203.47
..         ...   ...    ...       ...        ...

| Great job!

  |=================                                     |  32%

| The 'count' column, created with n(), contains the total number of rows (i.e. downloads)
| for each package. The 'unique' column, created with n_distinct(ip_id), gives the total
| number of unique downloads for each package, as measured by the number of distinct ip_id's.
| The 'countries' column, created with n_distinct(country), provides the number of countries
| in which each package was downloaded. And finally, the 'avg_bytes' column, created with
| mean(size), contains the mean download size (in bytes) for each package.

...

  |==================                                    |  34%

| It's important that you understand how each column of pack_sum was created and what it
| means. Now that we've summarized the data by individual packages, let's play around with it
| some more to see what we can learn.

...

  |===================                                   |  36%

| Naturally, we'd like to know which packages were most popular on the day these data were
| collected (July 8, 2014). Let's start by isolating the top 1% of packages, based on the
| total number of downloads as measured by the 'count' column.

...

  |=====================                                 |  38%

| We need to know the value of 'count' that splits the data into the top 1% and bottom 99% of
| packages based on total downloads. In statistics, this is called the 0.99, or 99%, sample
| quantile. Use quantile(pack_sum$count, probs = 0.99) to determine this number.

> quantile(pack_sum$count, probs = 0.99)
   99% 
679.56 

| You got it right!

  |======================                                |  40%

| Now we can isolate only those packages which had more than 679 total downloads. Use
| filter() to select all rows from pack_sum for which 'count' is strictly greater (>) than
| 679. Store the result in a new variable called top_counts.

> filter( pack_sum > 679)
Error in UseMethod("filter_") : 
  no applicable method for 'filter_' applied to an object of class "c('matrix', 'logical')"
> top_counts <- filterpack_sum( > 679)
Error: unexpected '>' in "top_counts <- filterpack_sum( >"
> ls
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern) 
{
    if (!missing(name)) {
        pos <- tryCatch(name, error = function(e) e)
        if (inherits(pos, "error")) {
            name <- substitute(name)
            if (!is.character(name)) 
                name <- deparse(name)
            warning(gettextf("%s converted to character string", 
                sQuote(name)), domain = NA)
            pos <- name
        }
    }
    all.names <- .Internal(ls(envir, all.names))
    if (!missing(pattern)) {
        if ((ll <- length(grep("[", pattern, fixed = TRUE))) && 
            ll != length(grep("]", pattern, fixed = TRUE))) {
            if (pattern == "[") {
                pattern <- "\\["
                warning("replaced regular expression pattern '[' by  '\\\\['")
            }
            else if (length(grep("[^\\\\]\\[<-", pattern))) {
                pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
                warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
            }
        }
        grep(pattern, all.names, value = TRUE)
    }
    else all.names
}
<bytecode: 0x26512c8>
<environment: namespace:base>

| Not quite right, but keep trying. Or, type info() for more options.

| Store the result of filter(pack_sum, count > 679) in a new variable called top_counts.

> top_counts <- filter( pack_sum, count > 679)

| Perseverance, that's the answer.

  |=======================                               |  42%

| Let's take a look at top_counts. Print it to the console.

> top_counts
Source: local data frame [61 x 5]

        package count unique countries  avg_bytes
1           DBI  2599    492        48  206933.25
2       Formula   852    777        65  155742.00
3         Hmisc   954    812        69 1367675.91
4          LPCM  2335     17        10  526814.23
5          MASS   834    698        66  981152.18
6        Matrix   932    801        66 3220134.17
7  RColorBrewer  1890   1584        79   22763.99
8         RCurl  1504   1207        73 1903505.32
9         RJDBC   809    107        28   18715.44
10      RJSONIO   751    585        60 1208103.99
..          ...   ...    ...       ...        ...

| All that practice is paying off!

  |========================                              |  44%

| There are only 61 packages in our top 1%, so we'd like to see all of them. Since dplyr only
| shows us the first 10 rows, we can use the View() function to see more.
| 
| Warning: The View() function may not work properly in every programming environment. We
| highly recommend the use of RStudio for the remainder of this lesson.

...

  |=========================                             |  46%

| View all 61 rows with View(top_counts). Note that the 'V' in View() is capitalized.

> View(top_counts)

| Perseverance, that's the answer.

  |==========================                            |  48%

| arrange() the rows of top_counts based on the 'count' column and assign the result to a new
| variable called top_counts_sorted. We want the packages with the highest number of
| downloads at the top, which means we want 'count' to be in descending order. If you need
| help, check out ?arrange and/or ?desc.

> ?arrange
> arrange(top_counts, desc(count))
Source: local data frame [61 x 5]

    package count unique countries  avg_bytes
1   ggplot2  4602   1680        81 2427716.05
2      Rcpp  3195   2044        84 2512100.35
3      plyr  2908   1754        81  799122.79
4     rJava  2773    963        70  633522.35
5       DBI  2599    492        48  206933.25
6      LPCM  2335     17        10  526814.23
7   stringr  2267   1948        82   65277.17
8    digest  2210   1894        83  120549.29
9  reshape2  2032   1652        76  330128.26
10  foreach  1984    485        53  358069.78
..      ...   ...    ...       ...        ...

| Almost! Try again. Or, type info() for more options.

| arrange(top_counts, desc(count)) will arrange the rows of top_counts based on the values of
| the 'count' variable, in descending order. Don't forget to assign the result to
| top_counts_sorted.

> top_counts_sorted <- arrange(top_counts, desc(count))

| Excellent job!

  |===========================                           |  50%

| Now use View() again to see all 61 rows of top_counts_sorted.

> View(top_counts_sorted)

| You are doing so well!

  |============================                          |  52%

| If we use total number of downloads as our metric for popularity, then the above output
| shows us the most popular packages downloaded from the RStudio CRAN mirror on July 8, 2014.
| Not surprisingly, ggplot2 leads the pack with 4602 downloads, followed by Rcpp, plyr,
| rJava, ....

...

  |=============================                         |  54%

| ...And if you keep on going, you'll see swirl at number 43, with 820 total downloads.
| Sweet!

...

  |==============================                        |  56%

| Perhaps we're more interested in the number of *unique* downloads on this particular day.
| In other words, if a package is downloaded ten times in one day from the same computer, we
| may wish to count that as only one download. That's what the 'unique' column will tell us.

...

  |===============================                       |  58%

| Like we did with 'count', let's find the 0.99, or 99%, quantile for the 'unique' variable
| with quantile(pack_sum$unique, probs = 0.99).

> quantile(pack_sum$unique, probs = 0.99)
99% 
465 

| That's correct!

  |================================                      |  60%

| Apply filter() to pack_sum to select all rows corresponding to values of 'unique' that are
| strictly greater than 465. Assign the result to a variable called top_unique.

> ?filter
> ?filter()
> top_unique <- filter( pack_sum, unique > 465)

| Keep working like that and you'll get there!

  |=================================                     |  62%

| Let's View() our top contenders!

> View(top_unique)

| That's a job well done!

  |===================================                   |  64%

| Now arrange() top_unique by the 'unique' column, in descending order, to see which packages
| were downloaded from the greatest number of unique IP addresses. Assign the result to
| top_unique_sorted.

> top_unique_sorted <- arrange(top_unique, desc(unique))

| All that hard work is paying off!

  |====================================                  |  66%

| View() the sorted data.

> View(top_unique_sorted)

| That's the answer I was looking for.

  |=====================================                 |  68%

| Now Rcpp is in the lead, followed by stringr, digest, plyr, and ggplot2. swirl moved up a
| few spaces to number 40, with 698 unique downloads. Nice!

...

  |======================================                |  70%

| Our final metric of popularity is the number of distinct countries from which each package
| was downloaded. We'll approach this one a little differently to introduce you to a method
| called 'chaining' (or 'piping').

...

  |=======================================               |  72%

| Chaining allows you to string together multiple function calls in a way that is compact and
| readable, while still accomplishing the desired result. To make it more concrete, let's
| compute our last popularity metric from scratch, starting with our original data.

...

  |========================================              |  74%

| I've opened up a script that contains code similar to what you've seen so far. Don't change
| anything. Just study it for a minute, make sure you understand everything that's there,
| then submit() when you are ready to move on.

> submit()

| Sourcing your script...

Source: local data frame [46 x 5]

        package count unique countries  avg_bytes
1          Rcpp  3195   2044        84 2512100.35
2        digest  2210   1894        83  120549.29
3       stringr  2267   1948        82   65277.17
4          plyr  2908   1754        81  799122.79
5       ggplot2  4602   1680        81 2427716.05
6    colorspace  1683   1433        80  357411.20
7  RColorBrewer  1890   1584        79   22763.99
8        scales  1726   1408        77  126819.33
9        bitops  1549   1408        76   28715.05
10     reshape2  2032   1652        76  330128.26
..          ...   ...    ...       ...        ...

| Keep up the great work!

  |=========================================             |  76%

| It's worth noting that we sorted primarily by country, but used avg_bytes (in ascending
| order) as a tie breaker. This means that if two packages were downloaded from the same
| number of countries, the package with a smaller average download size received a higher
| ranking.

...

  |==========================================            |  78%

| We'd like to accomplish the same result as the last script, but avoid saving our
| intermediate results. This requires embedding function calls within one another.

...

  |===========================================           |  80%

| That's exactly what we've done in this script. The result is equivalent, but the code is
| much less readable and some of the arguments are far away from the function to which they
| belong. Again, just try to understand what is going on here, then submit() when you are
| ready to see a better solution.

> submit()

| Sourcing your script...

Source: local data frame [46 x 5]

        package count unique countries  avg_bytes
1          Rcpp  3195   2044        84 2512100.35
2        digest  2210   1894        83  120549.29
3       stringr  2267   1948        82   65277.17
4          plyr  2908   1754        81  799122.79
5       ggplot2  4602   1680        81 2427716.05
6    colorspace  1683   1433        80  357411.20
7  RColorBrewer  1890   1584        79   22763.99
8        scales  1726   1408        77  126819.33
9        bitops  1549   1408        76   28715.05
10     reshape2  2032   1652        76  330128.26
..          ...   ...    ...       ...        ...

| You are amazing!

  |============================================          |  82%

| In this script, we've used a special chaining operator, %>%, which was originally
| introduced in the magrittr R package and has now become a key component of dplyr. You can
| pull up the related documentation with ?chain. The benefit of %>% is that it allows us to
| chain the function calls in a linear fashion. The code to the right of %>% operates on the
| result from the code to the left of %>%.
| 
| Once again, just try to understand the code, then type submit() to continue.

> submit()

| Sourcing your script...

Source: local data frame [46 x 5]

        package count unique countries  avg_bytes
1          Rcpp  3195   2044        84 2512100.35
2        digest  2210   1894        83  120549.29
3       stringr  2267   1948        82   65277.17
4          plyr  2908   1754        81  799122.79
5       ggplot2  4602   1680        81 2427716.05
6    colorspace  1683   1433        80  357411.20
7  RColorBrewer  1890   1584        79   22763.99
8        scales  1726   1408        77  126819.33
9        bitops  1549   1408        76   28715.05
10     reshape2  2032   1652        76  330128.26
..          ...   ...    ...       ...        ...

| Perseverance, that's the answer.

  |=============================================         |  84%

| So, the results of the last three scripts are all identical. But, the third script provides
| a convenient and concise alternative to the more traditional method that we've taken
| previously, which involves saving results as we go along.

...

  |==============================================        |  86%

| Once again, let's View() the full data, which has been stored in result3.

> View(result3)

| Excellent job!

  |================================================      |  88%

| It looks like Rcpp is on top with downloads from 84 different countries, followed by
| digest, stringr, plyr, and ggplot2. swirl jumped up the rankings again, this time to 27th.

...

  |=================================================     |  90%
| To help drive the point home, let's work through a few more examples of chaining.

...

  |==================================================    |  92%

| Let's build a chain of dplyr commands one step at a time, starting with the script I just
| opened for you.

> cran %>%
+   select(ip_id, country, package, size) %>%
+ 	print
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Give it another try.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Give it another try.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> ls
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern) 
{
    if (!missing(name)) {
        pos <- tryCatch(name, error = function(e) e)
        if (inherits(pos, "error")) {
            name <- substitute(name)
            if (!is.character(name)) 
                name <- deparse(name)
            warning(gettextf("%s converted to character string", 
                sQuote(name)), domain = NA)
            pos <- name
        }
    }
    all.names <- .Internal(ls(envir, all.names))
    if (!missing(pattern)) {
        if ((ll <- length(grep("[", pattern, fixed = TRUE))) && 
            ll != length(grep("]", pattern, fixed = TRUE))) {
            if (pattern == "[") {
                pattern <- "\\["
                warning("replaced regular expression pattern '[' by  '\\\\['")
            }
            else if (length(grep("[^\\\\]\\[<-", pattern))) {
                pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
                warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
            }
        }
        grep(pattern, all.names, value = TRUE)
    }
    else all.names
}
<bytecode: 0x26512c8>
<environment: namespace:base>
> cran %>%
+   select(ip_id, country, package, size) %>%
+ 	print()
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> skip
function () 
{
    invisible()
}
<environment: namespace:swirl>
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Almost! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> reset()

| I just reset the script to its original state. If it doesn't refresh immediately, you may
| need to click on it.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not exactly what I'm looking for. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not exactly what I'm looking for. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> print %>%
+ submit()
Error in submit(.) : unused argument (.)
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite right, but keep trying.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> cran %>%
+   select(ip_id, country, package, size) %>%
+ 	print
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Nice try, but that's not exactly what I was hoping for. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| One more time. You can do it!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> reset()

| I just reset the script to its original state. If it doesn't refresh immediately, you may
| need to click on it.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| You're close...I can feel it! Try it again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> exit()
Error: could not find function "exit"
> exit
Error: object 'exit' not found
> 0
[1] 0
> exit
Error: object 'exit' not found
> cran %>%
+   select(ip_id,
+          country,
+          package,
+          size,) %>%
+ 	print
Error in eval(expr, envir, enclos) : argument is missing, with no default
> cran %>%
+   select(ip_id,
+          country,
+          package,
+          size) %>%
+ 	print
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| You're close...I can feel it! Try it again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not exactly. Give it another go.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Keep trying!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| One more time. You can do it!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> cran %>%
+   select(ip_id,
+          country,
+          package,
+          size
+   ) %>%
+ 	print (cran)
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> cran %>%
+   select(ip_id) %>%
+   select(country) %>%
+   select(package) %>%
+   select(size) 
Error in eval(expr, envir, enclos) : object 'country' not found
> 	print
function (x, ...) 
UseMethod("print")
<bytecode: 0x5b23718>
<environment: namespace:base>
> cran %>%
+   select(ip_id) %>%
+   select(country) %>%
+   select(package) %>%
+   select(size) 
Error in eval(expr, envir, enclos) : object 'country' not found
> 	print (cran)
Source: local data frame [225,468 x 11]

    X       date     time    size r_version r_arch      r_os      package version country
1   1 2014-07-08 00:54:41   80589     3.1.0 x86_64   mingw32    htmltools   0.2.4      US
2   2 2014-07-08 00:59:53  321767     3.1.0 x86_64   mingw32      tseries 0.10-32      US
3   3 2014-07-08 00:47:13  748063     3.1.0 x86_64 linux-gnu        party  1.0-15      US
4   4 2014-07-08 00:48:05  606104     3.1.0 x86_64 linux-gnu        Hmisc  3.14-4      US
5   5 2014-07-08 00:46:50   79825     3.0.2 x86_64 linux-gnu       digest   0.6.4      CA
6   6 2014-07-08 00:48:04   77681     3.1.0 x86_64 linux-gnu randomForest   4.6-7      US
7   7 2014-07-08 00:48:35  393754     3.1.0 x86_64 linux-gnu         plyr   1.8.1      US
8   8 2014-07-08 00:47:30   28216     3.0.2 x86_64 linux-gnu      whisker   0.3-2      US
9   9 2014-07-08 00:54:58    5928        NA     NA        NA         Rcpp  0.10.4      CN
10 10 2014-07-08 00:15:35 2206029     3.0.2 x86_64 linux-gnu     hflights     0.1      US
.. ..        ...      ...     ...       ...    ...       ...          ...     ...     ...
Variables not shown: ip_id (int)
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Almost! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> ls
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern) 
{
    if (!missing(name)) {
        pos <- tryCatch(name, error = function(e) e)
        if (inherits(pos, "error")) {
            name <- substitute(name)
            if (!is.character(name)) 
                name <- deparse(name)
            warning(gettextf("%s converted to character string", 
                sQuote(name)), domain = NA)
            pos <- name
        }
    }
    all.names <- .Internal(ls(envir, all.names))
    if (!missing(pattern)) {
        if ((ll <- length(grep("[", pattern, fixed = TRUE))) && 
            ll != length(grep("]", pattern, fixed = TRUE))) {
            if (pattern == "[") {
                pattern <- "\\["
                warning("replaced regular expression pattern '[' by  '\\\\['")
            }
            else if (length(grep("[^\\\\]\\[<-", pattern))) {
                pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
                warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
            }
        }
        grep(pattern, all.names, value = TRUE)
    }
    else all.names
}
<bytecode: 0x26512c8>
<environment: namespace:base>
> reset
function () 
{
    invisible()
}
<environment: namespace:swirl>
> reset()

| I just reset the script to its original state. If it doesn't refresh immediately, you may
| need to click on it.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not exactly what I'm looking for. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Keep trying!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Try again. Getting it right on the first try is boring anyway!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Try again. Getting it right on the first try is boring anyway!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Try again. Getting it right on the first try is boring anyway!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite, but you're learning! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not the answer I was looking for, but try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Almost! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not the answer I was looking for, but try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| You almost had it, but not quite. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> 
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite, but you're learning! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| That's not the answer I was looking for, but try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Keep trying!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Almost! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Try again. Getting it right on the first try is boring anyway!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Give it another try.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Keep trying!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Give it another try.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| You almost had it, but not quite. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite, but you're learning! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Keep trying!

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Give it another try.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite, but you're learning! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| Not quite! Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> reset()

| I just reset the script to its original state. If it doesn't refresh immediately, you may
| need to click on it.

> submit()

| Sourcing your script...

Source: local data frame [225,468 x 0]


| You almost had it, but not quite. Try again.

| Follow the directions in the script comments very carefully. If R gave you an error above,
| try to understand what it is telling you. If you get stuck, type reset() to start with a
| fresh script, then save the script and type submit() when you are ready.

> cran %>%
+   select(ip_id,country,package,size) %>%
+ 	print
Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...
> submit()

| Sourcing your script...

Source: local data frame [225,468 x 4]

   ip_id country      package    size
1      1      US    htmltools   80589
2      2      US      tseries  321767
3      3      US        party  748063
4      3      US        Hmisc  606104
5      4      CA       digest   79825
6      3      US randomForest   77681
7      3      US         plyr  393754
8      5      US      whisker   28216
9      6      CN         Rcpp    5928
10     7      US     hflights 2206029
..   ...     ...          ...     ...

| Excellent job!

  |===================================================   |  94%

| Let's add to the chain.
| Sourcing your script...


| Perseverance, that's the answer.

  |====================================================  |  96%

| A little bit more now.
Sourcing your script...


| You are doing so well!

  |===================================================== |  98%

| And finish it off.
> submit()

| Sourcing your script...


| Great job!

  |======================================================| 100%

| In this lesson, you learned about grouping and chaining using dplyr. You combined some of
| the things you learned in the previous lesson with these more advanced ideas to produce
| concise, readable, and highly effective code. Welcome to the wonderful world of dplyr!

...

| Are you currently enrolled in the Coursera course associated with this lesson?

1: Yes
2: No

Selection: no
Enter an item from the menu, or 0 to exit
Selection: 0

| Would you like me to notify Coursera that you've completed this lesson? If so, I'll need to
| get some more info from you.

1: Yes
2: No
3: Maybe later

Selection: 3

| Is the following information correct?

Course ID: SRT411
Submission login (email): tmalladin@myseneca.ca
Submission password: tcphsTMA$1

1: Yes, go ahead!
2: No, I need to change something.

Selection: 1

| To notify Coursera that you have completed this lesson, please upload
| ‘SRT411_Grouping_and_Chaining_with_dplyr.txt’ to Coursera manually. You may do so by
| visiting the Programming Assignments page on your course website and selecting the Submit
| button next to the appropriate swirl lesson. I've placed the file in the following
| directory:

/home/tim

...

| You've reached the end of this lesson! Returning to the main menu...

Lesson 3:

| Please choose a course, or type 0 to exit swirl.

1: Getting and Cleaning Data
2: R Programming
3: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

1: Manipulating Data with dplyr
2: Grouping and Chaining with dplyr
3: Tidying Data with tidyr
4: Dates and Times with lubridate

Selection: 3

| Attemping to load lesson dependencies...

| This lesson requires the ‘tidyr’ package. Would you like me to install it for you now?

1: Yes
2: No

Selection: 1

| Trying to install package ‘tidyr’ now...
also installing the dependency ‘stringi’


| Package ‘tidyr’ loaded correctly!

| Package ‘dplyr’ loaded correctly!

  |                                                                                    |   0%

| In this lesson, you'll learn how to tidy your data with the tidyr package.

...

  |==                                                                                  |   2%

| Parts of this lesson will require the use of dplyr. If you don't have a basic knowledge of
| dplyr, you should exit this lesson and begin with the dplyr lessons from earlier in the
| course.

...

  |===                                                                                 |   4%

| tidyr was automatically installed (if necessary) and loaded when you started this lesson.
| Just to build the habit, (re)load the package with library(tidyr).

> library(tidyr)

| All that hard work is paying off!

  |=====                                                                               |   6%

| The author of tidyr, Hadley Wickham, discusses his philosophy of tidy data in his 'Tidy
| Data' paper:
| 
| http://vita.had.co.nz/papers/tidy-data.pdf
| 
| This paper should be required reading for anyone who works with data, but it's not required
| in order to complete this lesson.

...

  |======                                                                              |   8%

| Tidy data is formatted in a standard way that facilitates exploration and analysis and
| works seemlessly with other tidy data tools. Specifically, tidy data satisfies three
| conditions:
| 
| 1) Each variable forms a column
| 
| 2) Each observation forms a row
| 
| 3) Each type of observational unit forms a table

...

  |========                                                                            |   9%

| Any dataset that doesn't satisfy these conditions is considered 'messy' data. Therefore,
| all of the following are characteristics of messy data, EXCEPT...

1: Column headers are values, not variable names
2: Variables are stored in both rows and columns
3: A single observational unit is stored in multiple tables
4: Multiple types of observational units are stored in the same table
5: Multiple variables are stored in one column
6: Every column contains a different variable

Selection: 1

| You are amazing!

  |==========                                                                          |  11%

| The incorrect answers to the previous question are the most common symptoms of messy data.
| Let's work through a simple example of each of these five cases, then tidy some real data.

| The incorrect answers to the previous question are the most common symptoms of messy data.
| Let's work through a simple example of each of these five cases, then tidy some real data.

...

  |===========                                                                         |  13%

| The first problem is when you have column headers that are values, not variable names. I've
| created a simple dataset called 'students' that demonstrates this scenario. Type students
| to take a look.

> 
> students
  grade male female
1     A    1      5
2     B    5      0
3     C    5      2
4     D    5      5
5     E    7      4

| Keep up the great work!

  |=============                                                                       |  15%

| The first column represents each of five possible grades that students could receive for a
| particular class. The second and third columns give the number of male and female students,
| respectively, that received each grade.

...

  |==============                                                                      |  17%

| This dataset actually has three variables: grade, sex, and count. The first variable,
| grade, is already a column, so that should remain as it is. The second variable, sex, is
| captured by the second and third column headings. The third variable, count, is the number
| of students for each combination of grade and sex.

...

  |================                                                                    |  19%

| To tidy the students data, we need to have one column for each of these three variables.
| We'll use the gather() function from tidyr to accomplish this. Pull up the documentation
| for this function with ?gather.

> ?gather

| You are really on a roll!

  |=================                                                                   |  21%

| Using the help file as a guide, call gather() with the following arguments (in order):
| students, sex, count, -grade. Note the minus sign before grade, which says we want to
| gather all columns EXCEPT grade.

> gather(students, sex, count, -grade)
   grade    sex count
1      A   male     1
2      B   male     5
3      C   male     5
4      D   male     5
5      E   male     7
6      A female     5
7      B female     0
8      C female     2
9      D female     5
10     E female     4

| You are doing so well!

  |===================                                                                 |  23%

| Each row of the data now represents exactly one observation, characterized by a unique
| combination of the grade and sex variables. Each of our variables (grade, sex, and count)
| occupies exactly one column. That's tidy data!
...

  |=====================                                                               |  25%

| It's important to understand what each argument to gather() means. The data argument,
| students, gives the name of the original dataset. The key and value arguments -- sex and
| count, respectively -- give the column names for our tidy dataset. The final argument,
| -grade, says that we want to gather all columns EXCEPT the grade column (since grade is
| already a proper column variable.)

...

  |======================                                                              |  26%

| The second messy data case we'll look at is when multiple variables are stored in one
| column. Type students2 to see an example of this.

> students2
  grade male_1 female_1 male_2 female_2
1     A      3        4      3        4
2     B      6        4      3        5
3     C      7        4      3        8
4     D      4        0      8        1
5     E      1        1      2        7

| That's the answer I was looking for.

  |========================                                                            |  28%

| This dataset is similar to the first, except now there are two separate classes, 1 and 2,
| and we have total counts for each sex within each class. students2 suffers from the same
| messy data problem of having column headers that are values (male_1, female_1, etc.) and
| not variable names (sex, class, and count).

...

  |=========================                                                           |  30%

| However, it also has multiple variables stored in each column (sex and class), which is
| another common symptom of messy data. Tidying this dataset will be a two step process.

...

  |===========================                                                         |  32%

| Let's start by using gather() to stack the columns of students2, like we just did with
| students. This time, name the 'key' column sex_class and the 'value' column count. Save the
| result to a new variable called res. Consult ?gather again if you need help.

> res <- gather(students2, sex_class,key value,count -grade)
Error: unexpected symbol in "res <- gather(students2, sex_class,key value"
| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call gather() with the following arguments (in order): students2, sex_class, count,
| -grade). Store the result in a variable called res.

> res <- gather(students2, sex_class, count, -grade)

| Keep up the great work!

  |=============================                                                       |  34%

| Print res to the console to see what we accomplished.

> print(res)
   grade sex_class count
1      A    male_1     3
2      B    male_1     6
3      C    male_1     7
4      D    male_1     4
5      E    male_1     1
6      A  female_1     4
7      B  female_1     4
8      C  female_1     4
9      D  female_1     0
10     E  female_1     1
11     A    male_2     3
12     B    male_2     3
13     C    male_2     3
14     D    male_2     8
15     E    male_2     2
16     A  female_2     4
17     B  female_2     5
18     C  female_2     8
19     D  female_2     1
20     E  female_2     7

| You nailed it! Good job!

  |==============================                                                      |  36%

| That got us half way to tidy data, but we still have two different variables, sex and
| class, stored together in the sex_class column. tidyr offers a convenient separate()
| function for the purpose of separating one column into multiple columns. Pull up the help
| file for separate() now.
> ?separate

| Nice work!

  |================================                                                    |  38%

| Call separate() on res to split the sex_class column into sex and class. You only need to
| specify the first three arguments: data = res, col = sex_class, into = c("sex", "class").
| You don't have to provide the argument names as long as they are in the correct order.

> separate(data = res, col = sex_class, into = c("sex", "class"))
   grade    sex class count
1      A   male     1     3
2      B   male     1     6
3      C   male     1     7
4      D   male     1     4
5      E   male     1     1
6      A female     1     4
7      B female     1     4
8      C female     1     4
9      D female     1     0
10     E female     1     1
11     A   male     2     3
12     B   male     2     3
13     C   male     2     3
14     D   male     2     8
15     E   male     2     2
16     A female     2     4
17     B female     2     5
18     C female     2     8
19     D female     2     1
20     E female     2     7

| That's a job well done!

  |=================================                                                   |  40%

| Conveniently, separate() was able to figure out on its own how to separate the sex_class
| column. Unless you request otherwise with the 'sep' argument, it splits on non-alphanumeric
| values. In other words, it assumes that the values are separated by something other than a
| letter or number (in this case, an underscore.)

...

  |===================================                                                 |  42%

| Tidying students2 required both gather() and separate(), causing us to save an intermediate
| result (res). However, just like with dplyr, you can use the %>% operator to chain multiple
| function calls together.

...

  |====================================                                                |  43%

| I've opened an R script for you to give this a try. Follow the directions in the script,
| then save the script and type submit() at the prompt when you are ready. If you get stuck
| and want to start over, you can type reset() to reset the script to its original state.

> submit()

| Sourcing your script...

   grade    sex class count
1      A   male     1     3
2      B   male     1     6
3      C   male     1     7
4      D   male     1     4
5      E   male     1     1
6      A female     1     4
7      B female     1     4
8      C female     1     4
9      D female     1     0
10     E female     1     1
11     A   male     2     3
12     B   male     2     3
13     C   male     2     3
14     D   male     2     8
15     E   male     2     2
16     A female     2     4
17     B female     2     5
18     C female     2     8
19     D female     2     1
20     E female     2     7

| Great job!

  |======================================                                              |  45%
| A third symptom of messy data is when variables are stored in both rows and columns.
| students3 provides an example of this. Print students3 to the console.

> students3
    name    test class1 class2 class3 class4 class5
1  Sally midterm      A   <NA>      B   <NA>   <NA>
2  Sally   final      C   <NA>      C   <NA>   <NA>
3   Jeff midterm   <NA>      D   <NA>      A   <NA>
4   Jeff   final   <NA>      E   <NA>      C   <NA>
5  Roger midterm   <NA>      C   <NA>   <NA>      B
6  Roger   final   <NA>      A   <NA>   <NA>      A
7  Karen midterm   <NA>   <NA>      C      A   <NA>
8  Karen   final   <NA>   <NA>      C      A   <NA>
9  Brian midterm      B   <NA>   <NA>   <NA>      A
10 Brian   final      B   <NA>   <NA>   <NA>      C

| All that hard work is paying off!

  |========================================                                            |  47%

| In students3, we have midterm and final exam grades for five students, each of whom were
| enrolled in exactly two of five possible classes.

...

  |=========================================                                           |  49%

| The first variable, name, is already a column and should remain as it is. The headers of
| the last five columns, class1 through class5, are all different values of what should be a
| class variable. The values in the test column, midterm and final, should each be its own
| variable containing the respective grades for each student.

...

  |===========================================                                         |  51%

| This will require multiple steps, which we will build up gradually using %>%. Edit the R
| script, save it, then type submit() when you are ready. Type reset() to reset the script to
| its original state.

> ?gather
> submit()

| Sourcing your script...

    name    test  class grade
1  Sally midterm class1     A
2  Sally   final class1     C
3  Brian midterm class1     B
4  Brian   final class1     B
5   Jeff midterm class2     D
6   Jeff   final class2     E
7  Roger midterm class2     C
8  Roger   final class2     A
9  Sally midterm class3     B
10 Sally   final class3     C
11 Karen midterm class3     C
12 Karen   final class3     C
13  Jeff midterm class4     A
14  Jeff   final class4     C
15 Karen midterm class4     A
16 Karen   final class4     A
17 Roger midterm class5     B
18 Roger   final class5     A
19 Brian midterm class5     A
20 Brian   final class5     C

| You're the best!

  |============================================                                        |  53%

| The next step will require the use of spread(). Pull up the documentation for spread() now.

> ?spread

| You got it right!

  |==============================================                                      |  55%

| Edit the R script, then save it and type submit() when you are ready. Type reset() to reset
| the script to its original state.

> submit()

| Sourcing your script...

    name  class final midterm
1  Brian class1     B       B
2  Brian class5     C       A
3   Jeff class2     E       D
4   Jeff class4     C       A
5  Karen class3     C       C
6  Karen class4     A       A
7  Roger class2     A       C
8  Roger class5     A       B
9  Sally class1     C       A
10 Sally class3     C       B

| That's correct!

  |================================================                                    |  57%

| Lastly, we want the values in the class column to simply be 1, 2, ..., 5 and not class1,
| class2, ..., class5. We can use the extract_numeric() function from tidyr to accomplish
| this. To see how it works, try extract_numeric("class5").

> extract_numeric("class5")
[1] 5

| You're the best!

  |=================================================                                   |  58%
> submit()

| Sourcing your script...

    name class final midterm
1  Brian     1     B       B
2  Brian     5     C       A
3   Jeff     2     E       D
4   Jeff     4     C       A
5  Karen     3     C       C
6  Karen     4     A       A
7  Roger     2     A       C
8  Roger     5     A       B
9  Sally     1     C       A
10 Sally     3     C       B

| You got it!

  |===================================================                                 |  60%
| The fourth messy data problem we'll look at occurs when multiple observational units are
| stored in the same table. students4 presents an example of this. Take a look at the data
| now.

> students4
    id  name sex class midterm final
1  168 Brian   F     1       B     B
2  168 Brian   F     5       A     C
3  588 Sally   M     1       A     C
4  588 Sally   M     3       B     C
5  710  Jeff   M     2       D     E
6  710  Jeff   M     4       A     C
7  731 Roger   F     2       C     A
8  731 Roger   F     5       B     A
9  908 Karen   M     3       C     C
10 908 Karen   M     4       A     A

| You are doing so well!

  |====================================================                                |  62%

| students4 is almost the same as our tidy version of students3. The only difference is that
| students4 provides a unique id for each student, as well as his or her sex (M = male; F =
| female).

...

  |======================================================                              |  64%

| At first glance, there doesn't seem to be much of a problem with students4. All columns are
| variables and all rows are observations. However, notice that each id, name, and sex is
| repeated twice, which seems quite redundant. This is a hint that our data contains multiple
| observational units in a single table.

...

  |=======================================================                             |  66%

| Our solution will be to break students4 into two separate tables -- one containing basic
| student information (id, name, and sex) and the other containing grades (id, class,
| midterm, final).
| 
| Edit the R script, save it, then type submit() when you are ready. Type reset() to reset
| the script to its original state.

> submit()

| Sourcing your script...

    id  name sex
1  168 Brian   F
2  168 Brian   F
3  588 Sally   M
4  588 Sally   M
5  710  Jeff   M
6  710  Jeff   M
7  731 Roger   F
8  731 Roger   F
9  908 Karen   M
10 908 Karen   M

| Your dedication is inspiring!

  |=========================================================                           |  68%

| Notice anything strange about student_info? It contains five duplicate rows! See the script
| for directions on how to fix this. Save the script and type submit() when you are ready, or
| type reset() to reset the script to its original state.

> ?unique
> submit()

| Sourcing your script...

   id  name sex
1 168 Brian   F
3 588 Sally   M
5 710  Jeff   M
7 731 Roger   F
9 908 Karen   M

| Your dedication is inspiring!

  |===========================================================                         |  70%

| Now, using the script I just opened for you, create a second table called gradebook using
| the id, class, midterm, and final columns (in that order).
| 
| Edit the R script, save it, then type submit() when you are ready. Type reset() to reset
| the script to its original state.

> submit()

| Sourcing your script...

    id class midterm final
1  168     1       B     B
2  168     5       A     C
3  588     1       A     C
4  588     3       B     C
5  710     2       D     E
6  710     4       A     C
7  731     2       C     A
8  731     5       B     A
9  908     3       C     C
10 908     4       A     A

| You are amazing!

  |============================================================                        |  72%

| It's important to note that we left the id column in both tables. In the world of
| relational databases, 'id' is called our 'primary key' since it allows us to connect each
| student listed in student_info with their grades listed in gradebook. Without a unique
| identifier, we might not know how the tables are related. (In this case, we could have also
| used the name variable, since each student happens to have a unique name.)

...

  |==============================================================                      |  74%

| The fifth and final messy data scenario that we'll address is when a single observational
| unit is stored in multiple tables. It's the opposite of the fourth problem.

...

  |===============================================================                     |  75%

| To illustrate this, we've created two datasets, passed and failed. Take a look at passed
| now.

> passed
   name class final
1 Brian     1     B
2 Roger     2     A
3 Roger     5     A
4 Karen     4     A

| You nailed it! Good job!

  |=================================================================                   |  77%

| Now view the contents of failed.

> failed
   name class final
1 Brian     5     C
2 Sally     1     C
3 Sally     3     C
4  Jeff     2     E
5  Jeff     4     C
6 Karen     3     C

| You're the best!

  |===================================================================                 |  79%

| Teachers decided to only take into consideration final exam grades in determining whether
| students passed or failed each class. As you may have inferred from the data, students
| passed a class if they received a final exam grade of A or B and failed otherwise.

...

  |====================================================================                |  81%

| The name of each dataset actually represents the value of a new variable that we will call
| 'status'. Before joining the two tables together, we'll add a new column to each containing
| this information so that its not lost when we put everything together.

...

  |======================================================================              |  83%

| Use dplyr's mutate() to add a new column to the passed table. The column should be called
| status and the value, "passed" (a character string), should be the same for all students.
| 'Overwrite' the current version of passed with the new one.

> ?mutate
> mutate(gradebook, status ="passed")
    id class midterm final status
1  168     1       B     B passed
2  168     5       A     C passed
3  588     1       A     C passed
4  588     3       B     C passed
5  710     2       D     E passed
6  710     4       A     C passed
7  731     2       C     A passed
8  731     5       B     A passed
9  908     3       C     C passed
10 908     4       A     A passed

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| passed <- passed %>% mutate(status = "passed") will do the trick.

> passed <- passed %>% mutate(status ="passed")

| You are quite good my friend!

  |=======================================================================             |  85%

| Now, do the same for the failed table, except the status column should have the value
| "failed" for all students.

> failed <- failed %>% mutate(status ="failed")

| That's correct!

  |=========================================================================           |  87%

| Now, pass as arguments the passed and failed tables (in order) to the dplyr function
| bind_rows(), which will join them together into a single unit. Check ?bind_rows if you need
| help.
| 
| Note: bind_rows() is only available in dplyr 0.4.0 or later. If you have an older version
| of dplyr, please quit the lesson, update dplyr, then restart the lesson where you left off.
| If you're not sure what version of dplyr you have, type packageVersion('dplyr').

> packageVersion('dplyr')
[1] ‘0.4.1’

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Call bind_rows() with two arguments, passed and failed (in that order), to join the two
| tables.

> ?bind_rows
> bind_rows(passed,failed)
Source: local data frame [10 x 4]

    name class final status
1  Brian     1     B passed
2  Roger     2     A passed
3  Roger     5     A passed
4  Karen     4     A passed
5  Brian     5     C failed
6  Sally     1     C failed
7  Sally     3     C failed
8   Jeff     2     E failed
9   Jeff     4     C failed
10 Karen     3     C failed

| Keep working like that and you'll get there!

  |==========================================================================          |  89%

| Of course, we could arrange the rows however we wish at this point, but the important thing
| is that each row is an observation, each column is a variable, and the table contains a
| single observational unit. Thus, the data are tidy.

...

  |============================================================================        |  91%

| We've covered a lot in this lesson. Let's bring everything together and tidy a real
| dataset.

...

  |==============================================================================      |  92%

| The SAT is a popular college-readiness exam in the United States that consists of three
| sections: critical reading, mathematics, and writing. Students can earn up to 800 points on
| each section. This dataset presents the total number of students, for each combination of
| exam section and sex, within each of six score ranges. It comes from the 'Total Group
| Report 2013', which can be found here:
| 
| http://research.collegeboard.org/programs/sat/data/cb-seniors-2013

...

  |===============================================================================     |  94%

| I've created a variable called 'sat' in your workspace, which contains data on all
| college-bound seniors who took the SAT exam in 2013. Print the dataset now.

> sat
Source: local data frame [6 x 10]

  score_range read_male read_fem read_total math_male math_fem math_total write_male
1     700-800     40151    38898      79049     74461    46040     120501      31574
2     600-690    121950   126084     248034    162564   133954     296518     100963
3     500-590    227141   259553     486694    233141   257678     490819     202326
4     400-490    242554   296793     539347    204670   288696     493366     262623
5     300-390    113568   133473     247041     82468   131025     213493     146106
6     200-290     30728    29154      59882     18788    26562      45350      32500
Variables not shown: write_fem (int), write_total (int)

| You are quite good my friend!

  |=================================================================================   |  96%
| Type reset() to reset the script to its original state.
| As we've done before, we'll build up a series of chained commands, using functions from
| both tidyr and dplyr. Edit the R script, save it, then type submit() when you are ready.
| Type reset() to reset the script to its original state.

> submit()

| Sourcing your script...

Source: local data frame [36 x 4]

   score_range part  sex  count
1      700-800 read male  40151
2      600-690 read male 121950
3      500-590 read male 227141
4      400-490 read male 242554
5      300-390 read male 113568
6      200-290 read male  30728
7      700-800 read  fem  38898
8      600-690 read  fem 126084
9      500-590 read  fem 259553
10     400-490 read  fem 296793
..         ...  ...  ...    ...

| That's correct!

  |==================================================================================  |  98%

| Finish off the job by following the directions in the script. Save the script and type
| submit() when you are ready, or type reset() to reset the script to its original state.

> submit()

| Sourcing your script...

Source: local data frame [36 x 6]
Groups: part, sex

   score_range part  sex  count  total       prop
1      700-800 read male  40151 776092 0.05173485
2      600-690 read male 121950 776092 0.15713343
3      500-590 read male 227141 776092 0.29267278
4      400-490 read male 242554 776092 0.31253253
5      300-390 read male 113568 776092 0.14633317
6      200-290 read male  30728 776092 0.03959324
7      700-800 read  fem  38898 883955 0.04400450
8      600-690 read  fem 126084 883955 0.14263622
9      500-590 read  fem 259553 883955 0.29362694
10     400-490 read  fem 296793 883955 0.33575578
..         ...  ...  ...    ...    ...        ...

| Great job!

  |====================================================================================| 100%

| In this lesson, you learned how to tidy data with tidyr and dplyr. These tools will help
| you spend less time and energy getting your data ready to analyze and more time actually
| analyzing it.

...

| Are you currently enrolled in the Coursera course associated with this lesson?

1: Yes
2: No

Selection: 2

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.


Lesson 4:

| Please choose a course, or type 0 to exit swirl.

1: Getting and Cleaning Data
2: R Programming
3: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

1: Manipulating Data with dplyr
2: Grouping and Chaining with dplyr
3: Tidying Data with tidyr
4: Dates and Times with lubridate

Selection: 4

| Attemping to load lesson dependencies...

| This lesson requires the ‘lubridate’ package. Would you like me to install it for you now?

1: Yes
2: No

Selection: 1

| Trying to install package ‘lubridate’ now...
also installing the dependency ‘memoise’


| Package ‘lubridate’ loaded correctly!

  |                                                                                    |   0%

| In this lesson, we'll explore the lubridate R package, by Garrett Grolemund and Hadley
| Wickham. According to the package authors, "lubridate has a consistent, memorable syntax,
| that makes working with dates fun instead of frustrating." If you've ever worked with dates
| in R, that statement probably has your attention.

...

  |=                                                                                   |   2%

| Unfortunately, due to different date and time representations, this lesson is only
| guaranteed to work with an "en_US.UTF-8" locale. To view your locale, type
| Sys.getlocale("LC_TIME").

> Sys.getlocale("LC_TIME")
[1] "en_US.UTF-8"

| You nailed it! Good job!

  |===                                                                                 |   4%

| If the output above is not "en_US.UTF-8", this lesson is not guaranteed to work correctly.
| Of course, you are welcome to try it anyways. We apologize for this inconvenience.

...

  |====                                                                                |   5%

| lubridate was automatically installed (if necessary) and loaded upon starting this lesson.
| To build the habit, we'll go ahead and (re)load the package now. Type library(lubridate) to
| do so.

> library(lubridate)

| You got it!

  |======                                                                              |   7%

| lubridate contains many useful functions. We'll only be covering the basics here. Type
| help(package = lubridate) to bring up an overview of the package, including the package
| DESCRIPTION, a list of available functions, and a link to the official package vignette.

> help(package = lubridate)

| Perseverance, that's the answer.

  |=======                                                                             |   9%

| Let's get going!

...

  |=========                                                                           |  11%

| The today() function returns today's date. Give it a try, storing the result in a new
| variable called this_day.

> this_day <- today()

| All that hard work is paying off!

  |==========                                                                          |  12%

| Print the contents of this_day to the console.

> this_day
[1] "2015-03-23"

| Excellent job!

  |============                                                                        |  14%

| There are three components to this date. In order, they are year, month, and day. We can
| extract any of these components using the year(), month(), or day() function, respectively.
| Try any of those on this_day now.

> year(this_day)
[1] 2015

| Keep working like that and you'll get there!

  |=============                                                                       |  16%

| We can also get the day of the week from this_day using the wday() function. It will be
| represented as a number, such that 1 = Sunday, 2 = Monday, 3 = Tuesday, etc. Give it a
| shot.

> wday(this_day)
[1] 2

| Excellent job!

  |===============                                                                     |  18%

| Now try the same thing again, except this time add a second argument, label = TRUE, to
| display the *name* of the weekday (represented as an ordered factor).

> wday(this_day, label = TRUE)
[1] Mon
Levels: Sun < Mon < Tues < Wed < Thurs < Fri < Sat

| Keep working like that and you'll get there!

  |================                                                                    |  19%

| In addition to handling dates, lubridate is great for working with date and time
| combinations, referred to as date-times. The now() function returns the date-time
| representing this exact moment in time. Give it a try and store the result in a variable
| called this_moment.

> this_moment <- now()

| You are doing so well!

  |==================                                                                  |  21%

| View the contents of this_moment.

> this_moment 
[1] "2015-03-23 00:40:55 EDT"

| You are really on a roll!

  |===================                                                                 |  23%

| Just like with dates, we can extract the year, month, day, or day of week. However, we can
| also use hour(), minute(), and second() to extract specific time information. Try any of
| these three new functions now to extract one piece of time information from this_moment.

> second(this_monent)
Error in second(this_monent) : object 'this_monent' not found
> second(this_moment)
[1] 55.47843

| You are quite good my friend!

  |=====================                                                               |  25%

| today() and now() provide neatly formatted date-time information. When working with dates
| and times 'in the wild', this won't always (and perhaps rarely will) be the case.

...

  |======================                                                              |  26%

| Fortunately, lubridate offers a variety of functions for parsing date-times. These
| functions take the form of ymd(), dmy(), hms(), ymd_hms(), etc., where each letter in the
| name of the function stands for the location of years (y), months (m), days (d), hours (h),
| minutes (m), and/or seconds (s) in the date-time being read in.

...

  |========================                                                            |  28%

| To see how these functions work, try ymd("1989-05-17"). You must surround the date with
| quotes. Store the result in a variable called my_date.

> ymd("1989-05-17")
[1] "1989-05-17 UTC"

| Not quite! Try again. Or, type info() for more options.

| Type my_date <- ymd("1989-05-17") to see how ymd() works, storing the result in my_date.

> my_date <- ymd("1989-05-17")

| You are doing so well!

  |=========================                                                           |  30%

| Now take a look at my_date.

> my_date
[1] "1989-05-17 UTC"

| Keep working like that and you'll get there!

  |===========================                                                         |  32%

| It looks almost the same, except for the addition of a time zone, which we'll discuss later
| in the lesson. Below the surface, there's another important change that takes place when
| lubridate parses a date. Type class(my_date) to see what that is.

> class(my_date)
[1] "POSIXct" "POSIXt" 

| You got it!

  |============================                                                        |  33%

| So ymd() took a character string as input and returned an object of class POSIXct. It's not
| necessary that you understand what POSIXct is, but just know that it is one way that R
| stores date-time information internally.

...

  |=============================                                                       |  35%

| "1989-05-17" is a fairly standard format, but lubridate is 'smart' enough to figure out
| many different date-time formats. Use ymd() to parse "1989 May 17". Don't forget to put
| quotes around the date!

> ymd("1989 May 17")
[1] "1989-05-17 UTC"

| Perseverance, that's the answer.

  |===============================                                                     |  37%

| Despite being formatted differently, the last two dates had the year first, then the month,
| then the day. Hence, we used ymd() to parse them. What do you think the appropriate
| function is for parsing "March 12, 1975"? Give it a try.

> ymd("1975 March 12")
[1] "1975-03-12 UTC"

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| mdy() will correctly parse "March 12, 1975". The function name, mdy(), stands for year (y),
| month (m), and day (d), in order from left to right.

> mdy("March 12 1975")
[1] "1975-03-12 UTC"

| Keep up the great work!

  |================================                                                    |  39%

| We can even throw something funky at it and lubridate will often know the right thing to
| do. Parse 25081985, which is supposed to represent the 25th day of August 1985. Note that
| we are actually parsing a numeric value here -- not a character string -- so leave off the
| quotes.

> mdy(25081985)
[1] NA
Warning message:
All formats failed to parse. No formats found. 

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more
| options.

| Use dmy(25081985) to see how lubridate handles something a little different from what we've
| seen so far.

> dmy(25081985)
[1] "1985-08-25 UTC"

| Excellent work!

  |==================================                                                  |  40%

| But be careful, it's not magic. Try ymd("192012") to see what happens when we give it
| something more ambiguous. Surround the number with quotes again, just to be consistent with
| the way most dates are represented (as character strings).

> ymd("192012")
[1] NA
Warning message:
All formats failed to parse. No formats found. 

| Perseverance, that's the answer.

  |===================================                                                 |  42%

| You got a warning message because it was unclear what date you wanted. When in doubt, it's
| best to be more explicit. Repeat the same command, but add two dashes OR two forward
| slashes to "192012" so that it's clear we want January 2, 1920.

> ymd(--"192012")
Error in -"192012" : invalid argument to unary operator
> ymd(//"192012")
Error: unexpected '/' in "ymd(/"
> ymd(\\"192012")
Error: unexpected input in "ymd(\"
> ls()
 [1] "by_package"        "cran"              "cran2"             "cran3"            
 [5] "dt1"               "dt2"               "failed"            "gradebook"        
 [9] "my_date"           "my_div"            "my_sqrt"           "old.dir"          
[13] "pack_sum"          "passed"            "path2csv"          "res"              
[17] "result1"           "result2"           "result3"           "sat"              
[21] "stopwatch"         "student_info"      "students"          "students2"        
[25] "students3"         "students4"         "this_day"          "this_moment"      
[29] "top_countries"     "top_counts"        "top_counts_sorted" "top_unique"       
[33] "top_unique_sorted" "x"                 "y"                 "z"                

| Not quite, but you're learning! Try again. Or, type info() for more options.

| ymd("1920/1/2") is more explicit than ymd("192012") and lubridate knows how to handle it.

> ymd("1920-1-2")
[1] "1920-01-02 UTC"

| Nice work!

  |=====================================                                               |  44%

| In addition to dates, we can parse date-times. I've created a date-time object called dt1.
| Take a look at it now.

> dt1
[1] "2014-08-23 17:23:02"

| All that hard work is paying off!

  |======================================                                              |  46%

| Now parse dt1 with ymd_hms().

> ymd_hms(dt1)
[1] "2014-08-23 17:23:02 UTC"

| You are amazing!

  |========================================                                            |  47%

| What if we have a time, but no date? Use the appropriate lubridate function to parse
| "03:22:14" (hh:mm:ss).

> hms(03:22:14)
 [1] NA NA NA NA NA NA NA NA NA NA NA NA
Warning messages:
1: In 3:22:14 : numerical expression has 20 elements: only the first used
2: In .parse_hms(..., order = "HMS", quiet = quiet) :
  Some strings failed to parse

| Not exactly. Give it another go. Or, type info() for more options.

| Give hms("03:22:14") a try. In this case, hms() stands for hours (h), minutes (m), and
| seconds (s).

> hms("03:22:14")
[1] "3H 22M 14S"

| Excellent job!

  |=========================================                                           |  49%

| lubridate is also capable of handling vectors of dates, which is particularly helpful when
| you need to parse an entire column of data. I've created a vector of dates called dt2. View
| its contents now.

> dt2
[1] "2014-05-14" "2014-09-22" "2014-07-11"

| All that practice is paying off!

  |===========================================                                         |  51%

| Now parse dt2 using the appropriate lubridate function.

> ymd(dt2)
[1] "2014-05-14 UTC" "2014-09-22 UTC" "2014-07-11 UTC"

| Perseverance, that's the answer.

  |============================================                                        |  53%

| The update() function allows us to update one or more components of a date-time. For
| example, let's say the current time is 08:34:55 (hh:mm:ss). Update this_moment to the new
| time using the following command:
| 
| update(this_moment, hours = 8, minutes = 34, seconds = 55).

> update(this_moment, hours = 8, minutes = 34, seconds = 55)
[1] "2015-03-23 08:34:55 EDT"

| You got it!

  |==============================================                                      |  54%

| It's important to recognize that the previous command does not alter this_moment unless we
| reassign the result to this_moment. To see this, print the contents of this_moment.

> this_moment
[1] "2015-03-23 00:40:55 EDT"

| You are really on a roll!

  |===============================================                                     |  56%

| Unless you're a superhero, some time has passed since you first created this_moment. Use
| update() to make it match the current time, specifying at least hours and minutes. Assign
| the result to this_moment, so that this_moment will contain the new time.

> this_moment <- update(this_moment, hours = now(), minutes = now())

| You are really on a roll!

  |=================================================                                   |  58%

| Take one more look at this_moment to see that it's been updated.

> this_moment 
[1] NA

| You nailed it! Good job!

  |==================================================                                  |  60%

| Now, pretend you are in New York City and you are planning to visit a friend in Hong Kong.
| You seem to have misplaced your itinerary, but you know that your flight departs New York
| at 17:34 (5:34pm) the day after tomorrow. You also know that your flight is scheduled to
| arrive in Hong Kong exactly 15 hours and 50 minutes after departure.

...

  |====================================================                                |  61%

| Let's reconstruct your itinerary from what you can remember, starting with the full date
| and time of your departure. We will approach this by finding the current date in New York,
| adding 2 full days, then setting the time to 17:34.

...

  |=====================================================                               |  63%

| To find the current date in New York, we'll use the now() function again. This time,
| however, we'll specify the time zone that we want: "America/New_York". Store the result in
| a variable called nyc. Check out ?now if you need help.

> nyc <- now("America/New_York")

| That's a job well done!

  |=======================================================                             |  65%

| For a complete list of valid time zones for use with lubridate, check out the following
| Wikipedia page:
| 
| http://en.wikipedia.org/wiki/List_of_tz_database_time_zones

...

  |========================================================                            |  67%

| View the contents of nyc, which now contains the current date and time in New York.

> nyc 
[1] "2015-03-23 00:54:26 EDT"

| That's correct!

  |=========================================================                           |  68%

| Your flight is the day after tomorrow (in New York time), so we want to add two days to
| nyc. One nice aspect of lubridate is that it allows you to use arithmetic operators on
| dates and times. In this case, we'd like to add two days to nyc, so we can use the
| following expression: nyc + days(2). Give it a try, storing the result in a variable called
| depart.

> depart <- nyc + days(2)

| You got it right!

  |===========================================================                         |  70%

| Take a look at depart.

> depart 
[1] "2015-03-25 00:54:26 EDT"

| That's correct!

  |============================================================                        |  72%

| So now depart contains the date of the day after tomorrow. Use update() to add the correct
| hours (17) and minutes (34) to depart. Reassign the result to depart.

> depart <- update(depart, hours = 17, minutes = 34)

| You got it right!

  |==============================================================                      |  74%

| Take one more look at depart.

> depart 
[1] "2015-03-25 17:34:26 EDT"

| That's the answer I was looking for.

  |===============================================================                     |  75%

| Your friend wants to know what time she should pick you up from the airport in Hong Kong.
| Now that we have the exact date and time of your departure from New York, we can figure out
| the exact time of your arrival in Hong Kong.

...

  |=================================================================                   |  77%


